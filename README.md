# Backtesting Platform System Architecture Overview

## 1. Introduction

This document outlines the system architecture for a modular backtesting platform designed to evaluate trading algorithms. The platform aims to provide a flexible and extensible environment for quantitative developers to test various trading strategies against historical financial data, calculate key performance metrics, and visualize the results.

## 2. Architectural Principles

The design adheres to the following principles:

*   **Modularity:** Components are designed to be independent and interchangeable, allowing for easy integration of new data sources, strategies, and performance metrics.
*   **Extensibility:** The platform is built to be easily extended with new features and functionalities without requiring significant changes to the core system.
*   **Configurability:** Users can easily configure various aspects of the backtesting process, including data sources, strategy parameters, and reporting options.
*   **Performance:** The system is optimized for efficient processing of historical data and rapid backtest execution.
*   **Maintainability:** The codebase is clean, well-documented, and easy to understand, facilitating future maintenance and development.

## 3. System Components

The backtesting platform is composed of several key modules, each responsible for a specific set of functionalities:

### 3.1. Data Management Module

This module is responsible for handling all aspects of historical financial data. It includes:

*   **Data Loader:** Loads historical price and volume data from various sources (e.g., CSV files, databases, APIs). It should support different data granularities (e.g., daily, hourly, minute).
*   **Data Preprocessor:** Cleans, transforms, and prepares raw data for backtesting. This may include handling missing values, adjusting for stock splits/dividends, and calculating technical indicators.

### 3.2. Backtesting Engine

The core of the platform, responsible for simulating trades and managing the backtesting process. It includes:

*   **Trade Simulator:** Executes trades based on signals generated by the trading strategy, considering factors like transaction costs (commissions, slippage) and order types.
*   **Portfolio Manager:** Manages the simulated portfolio, tracking cash, positions, and equity over time.
*   **Event Handler:** Processes market data events and triggers strategy logic at appropriate times.

### 3.3. Strategy Interface

This module defines a standardized interface for plugging in custom trading strategies. Strategies interact with the backtesting engine through this interface, receiving market data and issuing trade orders.

### 3.4. Performance Metrics Module

Responsible for calculating a comprehensive set of performance metrics to evaluate strategy effectiveness. Key metrics include:

*   **Sharpe Ratio:** Measures risk-adjusted return.
*   **Sortino Ratio:** Similar to Sharpe, but focuses on downside deviation.
*   **Max Drawdown:** The largest peak-to-trough decline in equity.
*   **Win/Loss Ratio:** The ratio of profitable trades to losing trades.
*   **CAGR (Compound Annual Growth Rate):** The annualized rate of return.
*   **Volatility:** Measures the degree of variation of a trading price series over time.

### 3.5. Reporting and Visualization Module

Generates detailed reports and visualizations of backtest results. This includes:

*   **Report Generator:** Compiles performance metrics, trade logs, and other relevant information into a structured report.
*   **Visualization Tool:** Creates interactive charts and graphs (e.g., equity curves, drawdowns, trade distributions) to provide insights into strategy performance.

### 3.6. Logging Module

Records all significant events during the backtesting process, including data loading, trade execution, and error messages. This is crucial for debugging and auditing.

## 4. Data Flow

1.  **Data Loading:** Historical financial data is loaded and preprocessed by the Data Management Module.
2.  **Strategy Execution:** The Backtesting Engine feeds processed data to the selected Trading Strategy via the Strategy Interface.
3.  **Trade Simulation:** The Trading Strategy generates trade signals, which are then executed by the Trade Simulator within the Backtesting Engine.
4.  **Portfolio Updates:** The Portfolio Manager updates the simulated portfolio based on executed trades.
5.  **Performance Calculation:** After the backtest, the Performance Metrics Module calculates various metrics based on the portfolio\'s performance.
6.  **Reporting:** The Reporting and Visualization Module generates comprehensive reports and visualizations.
7.  **Logging:** All events are logged by the Logging Module throughout the process.

## 5. Technology Stack

*   **Programming Language:** Python
*   **Data Manipulation:** Pandas, NumPy
*   **Visualization:** Matplotlib, Plotly
*   **Data Storage (Optional):** SQLite (for local data storage)

## 6. Project Structure

```
backtesting_platform/
├── data/
├── strategies/
├── core/
│   ├── __init__.py
│   ├── data_loader.py
│   ├── backtesting_engine.py
│   ├── portfolio_manager.py
│   └── event_handler.py
├── metrics/
│   ├── __init__.py
│   └── performance_calculator.py
├── reports/
├── logs/
├── main.py
├── config.py
└── README.md
```

## 7. Conclusion

This architecture provides a robust and flexible foundation for a modular backtesting platform. Its component-based design ensures scalability and ease of maintenance, making it suitable for both simple and complex trading strategy evaluations.




## 2. Source Code with Documentation

This section provides the source code for each module of the backtesting platform, along with inline comments and docstrings for better understanding.

### 2.1. `backtesting_platform/core/data_loader.py`

This module handles the loading of historical financial data from CSV files.

```python



```python



import pandas as pd
import os

class DataLoader:
    """
    Handles loading historical financial data from various sources.
    """
    def __init__(self, data_path):
        self.data_path = data_path

    def load_csv(self, file_name):
        """
        Loads data from a CSV file.
        Assumes CSV has date as index and columns like 'Open', 'High', 'Low', 'Close', 'Volume'.
        Skips the first two rows which contain metadata.
        """
        full_path = os.path.join(self.data_path, file_name)
        try:
            # Skip the first two rows and read the 'Date' column as index
            df = pd.read_csv(full_path, index_col=0, parse_dates=True, skiprows=[1, 2])
            print(f"Successfully loaded data from {full_path}")
            return df
        except FileNotFoundError:
            print(f"Error: File {full_path} not found.")
            return None
        except Exception as e:
            print(f"An error occurred while loading {full_path}: {e}")
            return None


```

### 2.2. `backtesting_platform/core/portfolio_manager.py`

This module manages the simulated portfolio, tracking cash, positions, and equity over time.

```python



```python



class PortfolioManager:
    """
    Manages the simulated trading portfolio, tracking cash, positions, and equity.
    """
    def __init__(self, initial_cash):
        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.positions = {}
        self.equity_curve = []
        self.trades = []

    def update_portfolio(self, current_price, timestamp):
        """
        Updates the portfolio\'s equity curve based on current market prices.
        """
        current_equity = self.cash
        for symbol, position in self.positions.items():
            current_equity += position[\'quantity\'] * current_price.get(symbol, 0)
        self.equity_curve.append({\'timestamp\': timestamp, \'equity\': current_equity})

    def execute_trade(self, trade):
        """
        Executes a trade and updates cash and positions.
        Trade should be a dictionary with \'symbol\', \'type\' (buy/sell), \'quantity\', \'price\', \'commission\'.
        """
        symbol = trade[\'symbol\']
        trade_type = trade[\'type\']
        quantity = trade[\'quantity\']
        price = trade[\'price\']
        commission = trade.get(\'commission\', 0)

        if trade_type == \'buy\':
            cost = quantity * price + commission
            if self.cash >= cost:
                self.cash -= cost
                self.positions[symbol] = self.positions.get(symbol, {\'quantity\': 0, \'avg_price\': 0})
                current_total_cost = self.positions[symbol][\'quantity\'] * self.positions[symbol][\'avg_price\']
                new_total_cost = current_total_cost + quantity * price
                new_quantity = self.positions[symbol][\'quantity\'] + quantity
                self.positions[symbol][\'quantity\'] = new_quantity
                self.positions[symbol][\'avg_price\'] = new_total_cost / new_quantity if new_quantity > 0 else 0
                self.trades.append(trade)
                return True
            else:
                print(f"Insufficient cash to buy {quantity} of {symbol}")
                return False
        elif trade_type == \'sell\':
            if symbol in self.positions and self.positions[symbol][\'quantity\'] >= quantity:
                self.cash += quantity * price - commission
                self.positions[symbol][\'quantity\'] -= quantity
                if self.positions[symbol][\'quantity\'] == 0:
                    del self.positions[symbol]
                self.trades.append(trade)
                return True
            else:
                print(f"Insufficient {symbol} to sell {quantity}")
                return False
        return False


```

### 2.3. `backtesting_platform/core/backtesting_engine.py`

This module contains the core logic for running backtests.

```python



```python



import pandas as pd
from .data_loader import DataLoader
from .portfolio_manager import PortfolioManager
import logging

logging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")

class BacktestingEngine:
    """
    Core backtesting engine that simulates trades and manages the backtesting process.
    """
    def __init__(self, initial_cash, data_path):
        self.portfolio_manager = PortfolioManager(initial_cash)
        self.data_loader = DataLoader(data_path)
        self.strategy = None
        self.data = None

    def load_data(self, file_name):
        self.data = self.data_loader.load_csv(file_name)
        if self.data is not None:
            logging.info(f\"Data loaded successfully for {file_name}\")
        return self.data

    def set_strategy(self, strategy):
        self.strategy = strategy
        logging.info(f\"Strategy {strategy.__class__.__name__} set.\")

    def run_backtest(self):
        if self.data is None:
            logging.error(\"No data loaded. Please load data before running backtest.\")
            return
        if self.strategy is None:
            logging.error(\"No strategy set. Please set a strategy before running backtest.\")
            return

        logging.info(\"Starting backtest...\")
        self.strategy.initialize(self.portfolio_manager)

        # Pass the entire data to the strategy, and let the strategy handle slicing
        self.strategy.set_data(self.data)

        for i, (index, row) in enumerate(self.data.iterrows()):
            current_prices = {self.strategy.symbol: row[\"Close\"]}
            self.portfolio_manager.update_portfolio(current_prices, index)
            self.strategy.on_bar(i, row) # Pass index \'i\' for current position in data

        logging.info(\"Backtest finished.\")
        return self.portfolio_manager.equity_curve, self.portfolio_manager.trades


```

### 2.4. `backtesting_platform/metrics/performance_calculator.py`

This module calculates various performance metrics for a backtest.

```python



```python



import numpy as np
import pandas as pd

class PerformanceCalculator:
    """
    Calculates various performance metrics for a backtesting strategy.
    """
    def __init__(self, equity_curve, trades, risk_free_rate=0.02):
        self.equity_curve = pd.DataFrame(equity_curve).set_index(\"timestamp\")
        self.equity_curve[\"equity\"] = pd.to_numeric(self.equity_curve[\"equity\"])
        self.trades = trades
        self.risk_free_rate = risk_free_rate

    def calculate_returns(self):
        """
        Calculates daily returns from the equity curve.
        """
        self.equity_curve[\"returns\"] = self.equity_curve[\"equity\"].pct_change()
        return self.equity_curve[\"returns\"]

    def sharpe_ratio(self):
        """
        Calculates the Sharpe Ratio.
        (Mean Return - Risk-Free Rate) / Standard Deviation of Returns
        """
        returns = self.calculate_returns().dropna()
        if returns.empty:
            return 0.0
        annualized_returns = returns.mean() * 252  # Assuming 252 trading days in a year
        annualized_std = returns.std() * np.sqrt(252)
        if annualized_std == 0:
            return 0.0
        return (annualized_returns - self.risk_free_rate) / annualized_std

    def sortino_ratio(self):
        """
        Calculates the Sortino Ratio.
        (Mean Return - Risk-Free Rate) / Downside Deviation
        """
        returns = self.calculate_returns().dropna()
        if returns.empty:
            return 0.0
        downside_returns = returns[returns < 0]
        if downside_returns.empty:
            return np.inf  # No downside risk
        downside_std = downside_returns.std() * np.sqrt(252)
        annualized_returns = returns.mean() * 252
        if downside_std == 0:
            return 0.0
        return (annualized_returns - self.risk_free_rate) / downside_std

    def max_drawdown(self):
        """
        Calculates the Maximum Drawdown.
        """
        if self.equity_curve.empty:
            return 0.0
        equity = self.equity_curve[\"equity\"]
        peak = equity.expanding(min_periods=1).max()
        drawdown = (equity - peak) / peak
        return drawdown.min()

    def win_loss_ratio(self):
        """
        Calculates the Win/Loss Ratio.
        """
        if not self.trades:
            return 0.0

        wins = 0
        losses = 0

        # This is a simplified win/loss calculation. A more robust one would track individual trade PnL.
        # For now, we\"ll assume a \"win\" if the equity curve increased from the previous point.
        returns = self.calculate_returns().dropna()
        wins = (returns > 0).sum()
        losses = (returns < 0).sum()

        if losses == 0:
            return float(\"inf\") if wins > 0 else 0.0
        return wins / losses

    def cagr(self):
        """
        Calculates the Compound Annual Growth Rate (CAGR).
        """
        if self.equity_curve.empty:
            return 0.0
        start_equity = self.equity_curve[\"equity\"].iloc[0]
        end_equity = self.equity_curve[\"equity\"].iloc[-1]
        num_years = (self.equity_curve.index[-1] - self.equity_curve.index[0]).days / 365.25
        if num_years <= 0:
            return 0.0
        return (end_equity / start_equity)**(1 / num_years) - 1

    def volatility(self):
        """
        Calculates the annualized volatility of returns.
        """
        returns = self.calculate_returns().dropna()
        if returns.empty:
            return 0.0
        return returns.std() * np.sqrt(252)

    def generate_performance_report(self):
        """
        Generates a dictionary containing all calculated performance metrics.
        """
        report = {
            "Sharpe Ratio": self.sharpe_ratio(),
            "Sortino Ratio": self.sortino_ratio(),
            "Max Drawdown": self.max_drawdown(),
            "Win/Loss Ratio": self.win_loss_ratio(),
            "CAGR": self.cagr(),
            "Volatility": self.volatility(),
            "Initial Cash": self.equity_curve[\"equity\"].iloc[0] if not self.equity_curve.empty else self.risk_free_rate, # Using risk_free_rate as a placeholder if equity_curve is empty
            "Final Equity": self.equity_curve[\"equity\"].iloc[-1] if not self.equity_curve.empty else self.risk_free_rate, # Using risk_free_rate as a placeholder if equity_curve is empty
            "Total Trades": len(self.trades)
        }
        return report


```

### 2.5. `backtesting_platform/strategies/base_strategy.py`

This module defines the base class for all trading strategies.

```python



```python



class Strategy:
    """
    Base class for all trading strategies.
    """
    def __init__(self, symbol):
        self.symbol = symbol
        self.portfolio_manager = None
        self.data = None # This will now hold the full historical data
        self.current_index = -1 # Initialize current_index

    def initialize(self, portfolio_manager):
        self.portfolio_manager = portfolio_manager

    def set_data(self, data):
        self.data = data

    def on_bar(self, index, row):
        """
        This method is called for each bar (time period) of data.
        Subclasses should implement their trading logic here.
        `index` is the integer index of the current row in the full data.
        """
        self.current_index = index # Update current_index in on_bar
        raise NotImplementedError("on_bar method must be implemented by subclasses")

    def buy(self, quantity, price, commission=0):
        trade = {
            \"symbol\": self.symbol,
            \"type\": \"buy\",
            \"quantity\": quantity,
            \"price\": price,
            \"commission\": commission,
            \"timestamp\": self.data.index[self.current_index] # Use the timestamp from the data row
        }
        self.portfolio_manager.execute_trade(trade)

    def sell(self, quantity, price, commission=0):
        trade = {
            \"symbol\": self.symbol,
            \"type\": \"sell\",


            \"quantity\": quantity,
            \"price\": price,
            \"commission\": commission,
            \"timestamp\": self.data.index[self.current_index] # Use the timestamp from the data row
        }
        self.portfolio_manager.execute_trade(trade)


```

### 2.6. `backtesting_platform/strategies/moving_average_crossover.py`

This module implements the Moving Average Crossover strategy.

```python



from .base_strategy import Strategy
import pandas as pd
from collections import deque

class MovingAverageCrossover(Strategy):
    """
    A trading strategy based on the crossover of two moving averages.
    Buys when the short moving average crosses above the long moving average.
    Sells when the short moving average crosses below the long moving average.
    """
    def __init__(self, symbol, short_window=50, long_window=200):
        super().__init__(symbol)
        self.short_window = short_window
        self.long_window = long_window
        self.close_prices = deque(maxlen=long_window) # Use deque for efficient rolling window
        self.in_position = False

    def on_bar(self, index, row):
        self.current_index = index # Store current index for buy/sell methods
        self.close_prices.append(row["Close"])

        if len(self.close_prices) < self.long_window:
            return

        prices_series = pd.Series(list(self.close_prices))

        short_ma = prices_series.rolling(window=self.short_window).mean().iloc[-1]
        long_ma = prices_series.rolling(window=self.long_window).mean().iloc[-1]

        current_price = row["Close"]

        if short_ma > long_ma and not self.in_position:
            # Buy signal
            quantity_to_buy = int(self.portfolio_manager.cash / current_price)
            if quantity_to_buy > 0:
                self.buy(quantity_to_buy, current_price)
                self.in_position = True
                print(f"{row.name}: BUY {quantity_to_buy} of {self.symbol} at {current_price}")
        elif short_ma < long_ma and self.in_position:
            # Sell signal
            quantity_to_sell = self.portfolio_manager.positions.get(self.symbol, {}).get("quantity", 0)
            if quantity_to_sell > 0:
                self.sell(quantity_to_sell, current_price)
                self.in_position = False
                print(f"{row.name}: SELL {quantity_to_sell} of {self.symbol} at {current_price}")


```

### 2.7. `backtesting_platform/strategies/rsi_strategy.py`

This module implements the RSI-based strategy.

```python



from .base_strategy import Strategy
import pandas as pd
from collections import deque

class RSIStrategy(Strategy):
    """
    A trading strategy based on the Relative Strength Index (RSI).
    Buys when RSI crosses below a certain oversold threshold (e.g., 30).
    Sells when RSI crosses above a certain overbought threshold (e.g., 70).
    """
    def __init__(self, symbol, rsi_period=14, overbought_threshold=70, oversold_threshold=30):
        super().__init__(symbol)
        self.rsi_period = rsi_period
        self.overbought_threshold = overbought_threshold
        self.oversold_threshold = oversold_threshold
        self.close_prices = deque(maxlen=rsi_period) # Use deque for efficient rolling window
        self.in_position = False

    def calculate_rsi(self, prices, period):
        delta = prices.diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)

        avg_gain = gain.ewm(com=period - 1, min_periods=period).mean()
        avg_loss = loss.ewm(com=period - 1, min_periods=period).mean()

        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def on_bar(self, index, row):
        self.current_index = index # Store current index for buy/sell methods
        self.close_prices.append(row["Close"])

        if len(self.close_prices) < self.rsi_period:
            return

        prices_series = pd.Series(list(self.close_prices))
        rsi = self.calculate_rsi(prices_series, self.rsi_period).iloc[-1]

        current_price = row["Close"]

        if rsi < self.oversold_threshold and not self.in_position:
            # Buy signal
            quantity_to_buy = int(self.portfolio_manager.cash / current_price)
            if quantity_to_buy > 0:
                self.buy(quantity_to_buy, current_price)
                self.in_position = True
                print(f"{row.name}: BUY {quantity_to_buy} of {self.symbol} at {current_price}")
        elif rsi > self.overbought_threshold and self.in_position:
            # Sell signal
            quantity_to_sell = self.portfolio_manager.positions.get(self.symbol, {}).get("quantity", 0)
            if quantity_to_sell > 0:
                self.sell(quantity_to_sell, current_price)
                self.in_position = False
                print(f"{row.name}: SELL {quantity_to_sell} of {self.symbol} at {current_price}")


```

### 2.8. `backtesting_platform/strategies/mean_reversion.py`

This module implements the Mean Reversion strategy.

```python



from .base_strategy import Strategy
import pandas as pd
import numpy as np

class MeanReversion(Strategy):
    """
    A trading strategy based on the principle of mean reversion.
    Assumes that prices will revert to their historical average.
    Buys when price is significantly below a moving average.
    Sells when price is significantly above a moving average.
    """
    def __init__(self, symbol, window=20, num_std_dev=2):
        super().__init__(symbol)
        self.window = window
        self.num_std_dev = num_std_dev
        self.in_position = False

    def on_bar(self, index, row):
        self.current_index = index # Store current index for buy/sell methods

        if index < self.window - 1:
            return

        historical_data = self.data.iloc[:index+1]

        rolling_mean = historical_data["Close"].rolling(window=self.window).mean().iloc[-1]
        rolling_std = historical_data["Close"].rolling(window=self.window).std().iloc[-1]

        upper_band = rolling_mean + (rolling_std * self.num_std_dev)
        lower_band = rolling_mean - (rolling_std * self.num_std_dev)

        current_price = row["Close"]

        if current_price < lower_band and not self.in_position:
            # Buy signal
            quantity_to_buy = int(self.portfolio_manager.cash / current_price)
            if quantity_to_buy > 0:
                self.buy(quantity_to_buy, current_price)
                self.in_position = True
                print(f"{row.name}: BUY {quantity_to_buy} of {self.symbol} at {current_price}")
        elif current_price > upper_band and self.in_position:
            # Sell signal
            quantity_to_sell = self.portfolio_manager.positions.get(self.symbol, {}).get("quantity", 0)
            if quantity_to_sell > 0:
                self.sell(quantity_to_sell, current_price)
                self.in_position = False
                print(f"{row.name}: SELL {quantity_to_sell} of {self.symbol} at {current_price}")


```

### 2.9. `backtesting_platform/main.py`

This is the main script to run the backtests.

```python



import os
import pandas as pd
from core.backtesting_engine import BacktestingEngine
from metrics.performance_calculator import PerformanceCalculator
from strategies.moving_average_crossover import MovingAverageCrossover
from strategies.rsi_strategy import RSIStrategy
from strategies.mean_reversion import MeanReversion
import json

DATA_PATH = os.path.join(os.path.dirname(__file__), "data")
INITIAL_CASH = 100000

def run_single_backtest(strategy_class, ticker, initial_cash=INITIAL_CASH):
    print(f"\n--- Running Backtest for {strategy_class.__name__} on {ticker} ---")
    engine = BacktestingEngine(initial_cash=initial_cash, data_path=DATA_PATH)
    data_file = f"{ticker}.csv"
    data = engine.load_data(data_file)

    if data is None or data.empty:
        print(f"Could not load data for {ticker}. Skipping backtest.\n")
        return None, None

    strategy = strategy_class(symbol=ticker)
    engine.set_strategy(strategy)

    equity_curve, trades = engine.run_backtest()

    if equity_curve and trades:
        performance_calculator = PerformanceCalculator(equity_curve, trades)
        performance_report = performance_calculator.generate_performance_report()
        print(f"Performance Report for {strategy_class.__name__} on {ticker}:")
        for metric, value in performance_report.items():
            print(f"  {metric}: {value:.4f}")
        return equity_curve, performance_report
    else:
        print(f"No equity curve or trades generated for {strategy_class.__name__} on {ticker}.\n")
        return None, None

if __name__ == "__main__":
    tickers = ["AAPL", "MSFT", "GOOGL"]
    strategies = [
        MovingAverageCrossover,
        RSIStrategy,
        MeanReversion
    ]

    all_results = {}

    for ticker in tickers:
        all_results[ticker] = {}
        for strategy_class in strategies:
            equity_curve_list, performance_report = run_single_backtest(strategy_class, ticker)
            if equity_curve_list is not None and performance_report is not None:
                # Convert equity_curve_list (which is a list of dicts) to a DataFrame
                equity_curve_df = pd.DataFrame(equity_curve_list).set_index("timestamp")
                all_results[ticker][strategy_class.__name__] = {
                    "equity_curve": equity_curve_df.to_json(orient=\'split\'),
                    "performance_report": performance_report
                }

    output_file = os.path.join(os.path.dirname(__file__), "reports", "backtest_results.json")
    with open(output_file, "w") as f:
        json.dump(all_results, f, indent=4)
    print(f"\n--- All Backtests Completed. Results saved to {output_file} ---")


```

### 2.10. `backtesting_platform/plot_results.py`

This module generates plots of the equity curves.

```python



import pandas as pd
import matplotlib.pyplot as plt
import json
import os
import io

def plot_equity_curve(equity_curve_json, title, output_path):
    equity_curve_data = json.loads(equity_curve_json)
    equity_curve_df = pd.DataFrame(
        data=equity_curve_data["data"],
        index=pd.to_datetime(equity_curve_data["index"], unit=\"ms\"),
        columns=equity_curve_data["columns"]
    )

    plt.figure(figsize=(12, 6))
    plt.plot(equity_curve_df.index, equity_curve_df["equity"], label="Equity Curve")
    plt.title(title)
    plt.xlabel("Date")
    plt.ylabel("Equity")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()
    print(f"Saved equity curve plot to {output_path}")

if __name__ == "__main__":
    reports_dir = os.path.join(os.path.dirname(__file__), "reports")
    results_file = os.path.join(reports_dir, "backtest_results.json")

    with open(results_file, "r") as f:
        all_results = json.load(f)

    for ticker, strategies_results in all_results.items():
        for strategy_name, results in strategies_results.items():
            equity_curve_json = results["equity_curve"]
            plot_title = f"{ticker} - {strategy_name} Equity Curve"
            output_filename = f"{ticker}_{strategy_name}_equity_curve.png"
            output_path = os.path.join(reports_dir, output_filename)
            plot_equity_curve(equity_curve_json, plot_title, output_path)


```

## 3. Backtest Results and Interpretation

This section presents the backtest results for each implemented strategy across different assets, along with an interpretation of their performance.

### 3.1. Performance Metrics Summary

Below is a summary of key performance metrics for each strategy and asset combination.





## 3. Backtest Results and Interpretation

Here are the performance metrics for each strategy across the selected tickers (AAPL, MSFT, GOOGL). The initial capital for each backtest was $100,000.

### Performance Summary




```



| Ticker   | Strategy               |   Sharpe Ratio |   Sortino Ratio |   Max Drawdown |   Win/Loss Ratio |   CAGR |   Volatility |   Final Equity |   Total Trades |
|:---------|:-----------------------|---------------:|----------------:|---------------:|-----------------:|-------:|-------------:|---------------:|---------------:|
| AAPL     | MovingAverageCrossover |         0.4011 |          0.4603 |        -0.2657 |           1.0814 | 0.085  |       0.2072 |         138482 |              5 |
| AAPL     | RSIStrategy            |         0.4207 |          0.3514 |        -0.2587 |           1.1646 | 0.0982 |       0.2488 |         145327 |             28 |
| AAPL     | MeanReversion          |         0.3914 |          0.3111 |        -0.2587 |           1.1623 | 0.0886 |       0.2389 |         140322 |             22 |
| MSFT     | MovingAverageCrossover |         0.878  |          1.0112 |        -0.1944 |           1.1608 | 0.1725 |       0.1762 |         188678 |              3 |
| MSFT     | RSIStrategy            |         0.5011 |          0.4564 |        -0.2457 |           1.125  | 0.1221 |       0.255  |         158342 |             30 |
| MSFT     | MeanReversion          |         0.4712 |          0.4786 |        -0.352  |           1.0733 | 0.1178 |       0.2727 |         155917 |             18 |
| GOOGL    | MovingAverageCrossover |         1.0562 |          1.1036 |        -0.1565 |           1.2675 | 0.2285 |       0.1938 |         227270 |              3 |
| GOOGL    | RSIStrategy            |         0.5219 |          0.4747 |        -0.2576 |           1.1551 | 0.1259 |       0.248  |         160486 |             32 |
| GOOGL    | MeanReversion          |         0.4543 |          0.4346 |        -0.2729 |           1.0922 | 0.1092 |       0.2569 |         151196 |             22 |




### Interpretation of Results




#### Apple (AAPL)

*   **Moving Average Crossover:** This strategy showed a Sharpe Ratio of 0.4011 and a CAGR of 8.50%. It had a relatively low number of trades (5) and a Max Drawdown of -26.57%. The Win/Loss Ratio was 1.0814, indicating slightly more winning trades than losing ones.

*   **RSI Strategy:** With a Sharpe Ratio of 0.4207 and a CAGR of 9.82%, the RSI Strategy performed slightly better than the Moving Average Crossover for AAPL. It engaged in significantly more trades (28) and had a similar Max Drawdown of -25.87%. The Win/Loss Ratio was higher at 1.1646.

*   **Mean Reversion:** This strategy had a Sharpe Ratio of 0.3914 and a CAGR of 8.86%. It also had a high number of trades (22) and a Max Drawdown of -25.87%. The Win/Loss Ratio was 1.1623.

For AAPL, the **RSI Strategy** appears to be the best performer in terms of Sharpe Ratio and CAGR, although all three strategies showed similar Max Drawdowns.




#### Microsoft (MSFT)

*   **Moving Average Crossover:** This strategy performed exceptionally well on MSFT, with a Sharpe Ratio of 0.8780 and a CAGR of 17.25%. It had a very low number of trades (3) and a Max Drawdown of -19.44%. The Win/Loss Ratio was 1.1608.

*   **RSI Strategy:** The RSI Strategy for MSFT showed a Sharpe Ratio of 0.5011 and a CAGR of 12.21%. It had a higher number of trades (30) and a Max Drawdown of -24.57%. The Win/Loss Ratio was 1.1250.

*   **Mean Reversion:** This strategy had a Sharpe Ratio of 0.4712 and a CAGR of 11.78%. It had 18 trades and the highest Max Drawdown for MSFT at -35.20%. The Win/Loss Ratio was 1.0733.

For MSFT, the **Moving Average Crossover** clearly outperformed the other strategies across all key metrics, especially in terms of Sharpe Ratio and CAGR, with a significantly lower Max Drawdown.




#### Google (GOOGL)

*   **Moving Average Crossover:** This strategy was the top performer for GOOGL, with an impressive Sharpe Ratio of 1.0562 and a CAGR of 22.85%. It had a low number of trades (3) and the lowest Max Drawdown of -15.65%. The Win/Loss Ratio was 1.2675.

*   **RSI Strategy:** The RSI Strategy for GOOGL had a Sharpe Ratio of 0.5219 and a CAGR of 12.59%. It engaged in a high number of trades (32) and had a Max Drawdown of -25.76%. The Win/Loss Ratio was 1.1551.

*   **Mean Reversion:** This strategy showed a Sharpe Ratio of 0.4543 and a CAGR of 10.92%. It had 22 trades and a Max Drawdown of -27.29%. The Win/Loss Ratio was 1.0922.

For GOOGL, similar to MSFT, the **Moving Average Crossover** strategy demonstrated superior performance, indicating its effectiveness in capturing trends in these tech stocks during the backtesting period.





### Equity Curve Visualizations




#### AAPL

![AAPL Moving Average Crossover Equity Curve](backtesting_platform/reports/AAPL_MovingAverageCrossover_equity_curve.png)

![AAPL RSI Strategy Equity Curve](backtesting_platform/reports/AAPL_RSIStrategy_equity_curve.png)

![AAPL Mean Reversion Equity Curve](backtesting_platform/reports/AAPL_MeanReversion_equity_curve.png)

#### MSFT

![MSFT Moving Average Crossover Equity Curve](backtesting_platform/reports/MSFT_MovingAverageCrossover_equity_curve.png)

![MSFT RSI Strategy Equity Curve](backtesting_platform/reports/MSFT_RSIStrategy_equity_curve.png)

![MSFT Mean Reversion Equity Curve](backtesting_platform/reports/MSFT_MeanReversion_equity_curve.png)

#### GOOGL

![GOOGL Moving Average Crossover Equity Curve](backtesting_platform/reports/GOOGL_MovingAverageCrossover_equity_curve.png)

![GOOGL RSI Strategy Equity Curve](backtesting_platform/reports/GOOGL_RSIStrategy_equity_curve.png)

![GOOGL Mean Reversion Equity Curve](backtesting_platform/reports/GOOGL_MeanReversion_equity_curve.png)


